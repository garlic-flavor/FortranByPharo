"
I am generated by SWAnalyzer.
I have informations about Pharo's method.
"
Class {
	#name : #SWMethodInfo,
	#superclass : #SymbolicBytecodeBuilder,
	#instVars : [
		'mangledName',
		'stack',
		'return',
		'sourceHash',
		'classInfo'
	],
	#category : #'SWFortranByPharo-Client-Analyzer'
}

{ #category : #decoding }
SWMethodInfo class >> decode: selector types: types [
	^ self new
		method: (self search: selector in: types first);
		types: types;
		yourself
]

{ #category : #private }
SWMethodInfo class >> mangledTypeNameOf: aType [
	aType = Integer ifTrue: [ ^ #i ].
	aType = Float ifTrue: [ ^ #d ].
	^ #_
]

{ #category : #'instance creation' }
SWMethodInfo class >> newWith: method [
	^ self new
		method: method;
		yourself
]

{ #category : #utils }
SWMethodInfo class >> search: selector in: aClass [
	^ aClass ifNil: [
		nil
	] ifNotNil: [
		aClass methodDict at: selector ifAbsent: [
			self search: selector in: aClass superclass
		]
	]
]

{ #category : #accessing }
SWMethodInfo >> classInfo [

	^ classInfo
]

{ #category : #accessing }
SWMethodInfo >> classInfo: anObject [

	classInfo := anObject
]

{ #category : #testing }
SWMethodInfo >> hasExplicitReturn [
	^ self  return stackPos ~= -1
]

{ #category : #accessing }
SWMethodInfo >> mangledName [
	self halt.
	self flag: #toImplement.
	^ mangledName ifNil: [ mangledName := String streamContents: [ : s ||owner|
		owner := self method methodClass.
		owner class = Metaclass ifTrue: [ 
			s << owner soleInstance name; << 'C'
		] ifFalse: [
			s << owner name; << '_'
		].
		s << self method selector; << (self const ifTrue: ['C'] ifFalse: ['_']).
		self variables from: 1 to: self method numArgs do: [ :var |
			self class mangledTypeNameOf: var value class
		]
	] ]
]

{ #category : #accessing }
SWMethodInfo >> mangledName: anObject [

	mangledName := anObject
]

{ #category : #accessing }
SWMethodInfo >> name [

	^ self method selector asString
]

{ #category : #accessing }
SWMethodInfo >> return [

	^ return ifNil: [
		return := SWVariableInfo new
	]
]

{ #category : #accessing }
SWMethodInfo >> return: anObject [

	return := anObject
]

{ #category : #accessing }
SWMethodInfo >> sourceHash [
	^ sourceHash ifNil: [ sourceHash := SHA256 hashMessage: self method sourceCode ]
]

{ #category : #accessing }
SWMethodInfo >> stack [

	^ stack ifNil: [
		stack := SWStack new.
		self method numTemps + 1 timesRepeat: [
			stack push: SWVariableInfo new
		].
		(stack at: 0)
			name: 'self';
			stackPos: 0.
		self method temporaryVariables doWithIndex: [ :var :idx |
			(stack at: idx)
				name: var name;
				stackPos: idx
		].
		stack
	]
]

{ #category : #accessing }
SWMethodInfo >> stack: anObject [

	stack := anObject
]

{ #category : #accessing }
SWMethodInfo >> types: anObject [

	anObject doWithIndex: [ :type :idx |
		(self stack at: idx - 1)
			type: type
	]
]

{ #category : #accessing }
SWMethodInfo >> variableInfoOf: aName [
	^ self stack detect: [ :vi |
		vi name = aName
	] ifNone: [
		self classInfo variableInfoOf: aName
	]
]
